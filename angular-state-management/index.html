<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">

	<title>Jeroen Berndsen: Angular state management</title>

	<meta name="description" content="Presentation: Angular state management">
	<meta name="author" content="Jeroen Berndsen">

	<meta name="apple-mobile-web-app-capable" content="yes" />
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">


	<link rel="stylesheet" href="css/reveal.css">
	<link rel="stylesheet" href="css/theme/simple.css" id="theme">
	<link rel="stylesheet" href="css/inputs.css">

	<!-- Code syntax highlighting -->
	<link rel="stylesheet" href="lib/css/zenburn.css">

	<!-- Printing and PDF exports -->
	<script>
		var link = document.createElement('link');
		link.rel = 'stylesheet';
		link.type = 'text/css';
		link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
		document.getElementsByTagName('head')[0].appendChild(link);
	</script>

	<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
	<![endif]-->
</head>

<body>
	<div class="reveal">
		<div class="slides">

			<!-- OPENING -->
			<!-- todo: reusable title slide -->
			<section data-background="img/angular_wallpaper.jpeg"></section>

			<section data-background="img/toubkal_jeroen.jpg"></section>

			<section data-background="img/frontmen.png"></section>

			<!-- INTRODUCTION -->
			<section>
				<section>
					<p>Angular is all about creating isolated, declarative, reusable components.</p>
					<img src="img/view component.png" />
				</section>
				<section>
					<p>An Angular app is composed of these components</p>
					<img src="img/component tree.png" />
				</section>
				<section>
					<p>Often, application data is reflected in multiple components. This introduces a synchronisation problem when a component decides to update this data.</p>
				</section>
				<section>
					<p>Ad-hoc solutions would mean components cannot be developed in isolation.</p>
					<img src="img/no redux.png" />
				</section>
				<section>
					<ul>
						<li>Development complexity increased, because developer needs to be aware of impact on the entire application.</li>
						<li>Tracing the origin of inconsistency issues is non-trivial.</li>
						<li>Even more so in production, app can get out of sync due to networking errors.</li>
					</ul>
				</section>
				<section data-background="img/backdrop_1.png">
					<p><strong>State management</strong> is about choosing an explicit strategy for dealing with this data synchronization problem.</p>
				</section>
				<section>
					<p><strong>Problem 1:</strong> Ensuring that the application is consistent within itself.</p>
				</section>
				<section>
					<p><strong>Problem 2:</strong> Enabling developers to reason about components in an isolated fashion.</p>
				</section>
				<section>
					<p><strong>Problem 3:</strong> Allowing for consistent reasoning about application state, even in the face of network race conditions.</p>
				</section>
				<section>
					<p><strong>Problem 4:</strong> Testability and tooling to inspect application state behavior.</p>
				</section>
			</section>

			<!-- WHAT IS STATE MANAGEMENT -->
			<section>
				<section>
					<h2>Types of state</h2>
					<p class="spacey">
						<p class="fragment roll-in">Back-end state: Server responses and cached data</p>
						<p class="fragment roll-in">Client persistent state: locally created data and UI state</p>
						<p class="fragment roll-in"> Router / URL state</p>
					</p>
				</section>
				<section data-background="img/backdrop_1.png">
					<strong>Redux</strong> is a popular solution that attempts to make state mutations predictable by imposing restrictions on how and when updates can happen.
				</section>
				<section data-background="img/backdrop_1.png">
					<p><strong>Rule 1:</strong> The state of your whole application is stored in an object tree within a single store.</p>
				</section>
				<section data-background="img/backdrop_1.png">
					<strong>Rule 2:</strong> The state is read-only. Components subscribe to store changes and render accordingly.
				</section>
				<section data-background="img/backdrop_1.png">
					<p><strong>Rule 3:</strong> The only way to change the store is to emit an action, an object describing what happened.</strong></p>	
				</section>
				<section data-background="img/backdrop_1.png">
					<strong>Rule 4:</strong> To specify how the state tree is transformed by actions, you write pure <i>reducer</i> functions.
				</section>
				<section>
					<img src="img/no redux.png" />
				</section>
				<section>
					<img src="img/redux.png" />
				</section>
				<section>
					<img src="img/unidirectional.svg" />
				</section>
			</section>

			<!-- The store and view, think of as database -->
			<section>
				gevormd door initiele data (meestal een lege array of object), waardevol om te typeren.
				en functies (reducers) die beschrijven hoe de state veranderd op basis van een actie
			</section>

			<!-- actions, action creators -->
			<section>
				een actie is simpelweg een object die beschrijft wat er is gebeurd.
				heeft een type (om hem aan te herkennen) en optioneel een payload (extra data)
				gebruik action creators om ze meer herbruikbaar en testbaar te maken
				Typescript classes lenen zich hier goed voor, zo kan je ook de payload typeren.
				Bij acties is de verwachting van de vorm van de data (payload) groot, reducer implementatie leunt hier op
			</section>

			<!-- reducers, think of as tables -->
			<section>
				Een reducer beschrijft hoe een gegeven de huidige state en een actie de state veranderd. (state, action) -> state*
				Is een pure functie. als dit niet zo zou zijn kunnen we niet time-travel debuggen, omdat het niet mogelijk is
				correct tussen states te switchen.
			</section>

			<section>welke van onze problemen hebben we tot nu toe opgelost hiermee? tegen welke prijs?</section>


			<!-- router state synchroniseren: maak de router single source of truth + router-store -->

			<!-- netwerk race condities: switchMap pakt altijd de laatste, expliciete undo strategy -->

			<!-- inconsistentie in de state: genormaliseerde data en selectors, think of as queries -->

			<!-- performance in NG2: immutability and changedetectionstrategy -->
			<section>
			Immutably updating state generally means making shallow copies, not deep copies. Shallow copies are much faster than deep copies, because fewer objects and fields have to be copied, and it effectively comes down to moving some pointers around.

However, you do need to create a copied and updated object for each level of nesting that is affected. Although that shouldn't be particularly expensive, it's another good reason why you should keep your state normalized and shallow if possible.

Common Redux misconception: you need to deeply clone the state. Reality: if something inside doesn't change, keep its reference the same!
Immutability can bring increased performance to your app, and leads to simpler programming and debugging, as data that never changes is easier to reason about than data that is free to be changed arbitrarily throughout your app.

In particular, immutability in the context of a Web app enables sophisticated change detection techniques to be implemented simply and cheaply, ensuring the computationally expensive process of updating the DOM occurs only when it absolutely has to
</section>
			<!-- CLOSING -->
			<section>
				<div style="width: 70%; float: left"><img src="img/frontmen-2.png" style="border: 0;"></div>
				<div style="width: 30%; float: right">
					<p>Thank you!</p>
					<p class="spacey">Reach me at <span class="orange">jeroen@frontmen.nl</span></p>
					
				</div>
				<p class="light">http://presentations.jberndsen.nl/angular-state-management</p>
			</section>
		</div>
	</div>
 


	<script src="lib/js/head.min.js"></script>
	<script src="js/reveal.js"></script>
	<script>
		// Full list of configuration options available at:
		// https://github.com/hakimel/reveal.js#configuration
		Reveal.initialize({
			controls: false,
			progress: true,
			history: true,
			center: true,

			transition: 'slide', // none/fade/slide/convex/concave/zoom

			// Optional reveal.js plugins
			dependencies: [
				{ src: 'lib/js/classList.js', condition: function () { return !document.body.classList; } },
				{ src: 'plugin/markdown/marked.js', condition: function () { return !!document.querySelector('[data-markdown]'); } },
				{ src: 'plugin/markdown/markdown.js', condition: function () { return !!document.querySelector('[data-markdown]'); } },
				{ src: 'plugin/highlight/highlight.js', async: true, condition: function () { return !!document.querySelector('pre code'); }, callback: function () { hljs.initHighlightingOnLoad(); } },
				{ src: 'plugin/zoom-js/zoom.js', async: true },
				{ src: 'plugin/notes/notes.js', async: true }
			]
		});
	</script>
</body>

</html>